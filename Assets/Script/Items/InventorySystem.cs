using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Unity.VisualScripting;
using UnityEngine;
using static UnityEditor.Progress;

public class InventorySystem : MonoBehaviour
{
    [Header("Drag and Drop")]
    [SerializeField] private Transform _quickTransform;
    [SerializeField] private Transform _slotTransform;
    [SerializeField] private Canvas _canvas;

    [Header("inventory Data")]
    [SerializeField] private int _inventorySize = 28;
    [SerializeField] private Item[] _inventory;
    public Item[] inventory => _inventory;

    [Header("Slots")]
    [SerializeField] private List<ItemSlot> _slots;

    private int _slotIndex;
    [Header("tempData")]
    public int _selectIndex;
    private void Awake()
    {
        // 0~7  -> 퀵 슬롯
        // 8~27 -> 인벤토리 슬롯
        _inventory = new Item[_inventorySize];
        _slots = new List<ItemSlot>();

        for (int i = 0; i < _quickTransform.childCount; i++)
            _slots.Add(_quickTransform.GetChild(i).GetComponent<ItemSlot>());

        for (int i = 0; i < _slotTransform.childCount; i++)
            _slots.Add(_slotTransform.GetChild(i).GetComponent<ItemSlot>());

        for(int i = 0; i < _slots.Count; i++)
            _slots[i]._slotIndex = i;

        F_InventoryUIUpdate();
    }

    public bool F_GetItem(int v_code)
    {
        // 동일한 아이템 /
        for(int index = 0; index < _inventorySize; index++)
        {
            if (_inventory[index] == null)   // 빈칸
                continue;

            // 동일한 아이템 + 아이템 개수 추가 가능할때
            if (_inventory[index].F_CheckItemCode(v_code) && _inventory[index].F_CheckStack())
            {
                _inventory[index].F_AddStack(1);
                Debug.Log("Get : " + _inventory[index].itemName);
                return true;
            }
        }

        // 동일한 아이템이 없을때
        for(int index = 0; index < _inventorySize; index++)
        {
            if (_inventory[index] == null)    // 빈칸 일때
            {
                ItemData data = ItemManager.Instance.ItemDatas[v_code];
                switch(data._itemType)
                {
                    case ItemType.STUFF:
                        _inventory[index] = new Stuff(data);
                        break;

                    case ItemType.FOOD:
                        _inventory[index] = new Food(data);
                        break;

                    case ItemType.TOOL:
                        _inventory[index] = new Tool(data);
                        break;

                    case ItemType.INSTALL:
                        _inventory[index] = new Install(data);
                        break;
                }
                Debug.Log("Get : " + _inventory[index].itemName);
                return true; // 아이템 추가 성공
            }
        }
        return false; // 아이템 추가 실패
    }

    public void F_InventoryUIUpdate()
    {
        //인벤토리 배열에 있는 데이터를 UI에 출력하는 함수
        for(int i = 0; i < _slots.Count; i++)
        {
            if (_inventory[i] == null)
                _slots[i].F_EmptySlot();
            else
                _slots[i].F_UpdateSlot(_inventory[i].itemCode, _inventory[i].currentStack);
        }
    }

    public void F_SwapItem(int v_sIndex, int v_eIndex)
    {
        // 같은 위치일 경우 동작 X
        if (v_sIndex == v_eIndex)
            return;
        
        // 비어있는 칸으로 이동
        if (inventory[v_eIndex] == null)
        {
            inventory[v_eIndex] = inventory[v_sIndex];
            inventory[v_sIndex] = null;
        }

        // 다른 아이템일때 ( 스왑 )
        else if (!inventory[v_sIndex].F_CheckItemCode(inventory[v_eIndex].itemCode))
        {
            Item tmp_item = inventory[v_eIndex];
            inventory[v_eIndex] = inventory[v_sIndex];
            inventory[v_sIndex] = tmp_item;
        }

        // 같은 아이템일때 
        else
        {
            // 스왑하는 아이템의 maxStack이 1인 경우 그냥 스왑 ( 도구 / 설치류 )
            if (inventory[v_eIndex].maxStack == 1)
            {
                Item tmp_item = inventory[v_eIndex];
                inventory[v_eIndex] = inventory[v_sIndex];
                inventory[v_sIndex] = tmp_item;
            }
            else
            {
                // 32 - 현재스택 => 더 채울수 있는 스택
                int canAddStack = inventory[v_eIndex].maxStack - inventory[v_eIndex].currentStack;
                // 채울 스택
                int stack = inventory[v_sIndex].currentStack;

                // 채워야할 스택이 더 적을때
                if(stack <= canAddStack)
                {
                    inventory[v_sIndex] = null;
                    inventory[v_eIndex].F_AddStack(stack);
                }
                // 채워야할 스택이 더 많을때
                else
                {
                    // sindex의 스택이 canAddStack만큼 줄어듬
                    inventory[v_sIndex].F_AddStack(-canAddStack);
                    // eindex의 스택이 canAddStack만큼 늘어남
                    inventory[v_eIndex].F_AddStack(canAddStack);
                }
            }
        }
        F_InventoryUIUpdate();
    }

    public void F_DeleteItem()
    {
        if (_selectIndex == -1)
            return;
        inventory[_selectIndex] = null;

        F_InventoryUIUpdate();
        UIManager.Instance.F_SlotFuntionUIOff();
        UIManager.Instance.F_UpdateItemInformation_Empty();
    }

    public void F_UseItem(int v_slotNumber)
    {
        
    }
}